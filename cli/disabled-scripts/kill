#!/usr/bin/env python3.11

# Copyright (C) 2024-2025 Burak Günaydin
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.

# System imports
from logging import warn
import os
import signal
import time
import psutil

# From system imports
from typing import List

# From package imports
from teatype.cli import BaseCLI
from teatype.io import clear, enable_sudo
from teatype.logging import *

class Kill(BaseCLI):
    """
    A CLI tool to search for processes by name or command-line fragment,
    display matches, and kill them by index or all at once using
    a sequence of signals (SIGINT, SIGTERM, SIGKILL).
    """
    def meta(self):
        return {
            'name': 'kill',
            'shorthand': 'kl',
            'help': 'Search for and kill matching processes interactively',
            'arguments': [
                {
                    'name': 'process-name',
                    'help': 'The name or command-line fragment of the process to search for',
                    'required': True
                }
            ]
        }
        
    def refresh_matches(self, process_name:str, matches:List):
        for process in psutil.process_iter(['pid', 'name', 'cmdline']):
            try:
                name = process.info['name'] or ''
                cmd  = ' '.join(process.info['cmdline'] or [])
                fragment = process_name.lower()
                if fragment in name.lower() or fragment in cmd.lower():
                    if 'python3.11 /root/arsonite/teatype/cli/tt kill' in cmd:
                        continue # Skip self
                    matches.append(process)
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                continue

    def display_matches(self, matches:List):
        println()
        if not matches:
            err('No matching processes found.', use_prefix=False, verbose=False)
            return
        
        log('Matched processes:')
        for index, process in enumerate(matches, start=1):
            try:
                name = process.name()
                cmd  = ' '.join(process.cmdline())
                log(f'  [{index}] {name}', color='green')
                log(f'      • pid: {process.pid}', color='magenta')
                log(f'      • command: {cmd}', color='magenta')
                println()
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                continue

    def kill_processes(self, processes_to_kill:List):
        for sig in (signal.SIGINT, signal.SIGTERM, signal.SIGKILL):
            for p in processes_to_kill:
                try:
                    os.kill(p.pid, sig)
                except ProcessLookupError:
                    pass
            time.sleep(0.1)

    def execute(self):
        clear()
        enable_sudo()
        
        process_name = self.get_argument('process-name')
        matches = []
        try:
            # initial search
            self.refresh_matches(process_name, matches)

            while True:
                self.display_matches(matches)
                if not matches:
                    break
                
                hint('Press CTRL+C or type `q` to quit.', use_prefix=False)
                println()
                prompt = 'Enter `<number>` to kill a specific process, leave blank to kill all:\n> '
                choice = input(prompt).strip()

                if choice.lower() in ('q'):
                    println()
                    warn('Exiting.')
                    break

                if choice == '':
                    self.kill_processes(matches)
                elif choice.isdigit():
                    index = int(choice)
                    if 1 <= index <= len(matches):
                        self.kill_processes([matches[index - 1]])
                    else:
                        clear()
                        err(f'Index {index} out of range.')
                        continue
                else:
                    clear()
                    err('Invalid choice. Use a number, blank to kill all, or "q" to quit.', pad_before=1)
                    continue

                # refresh remaining matches
                matches = [p for p in matches if p.is_running()]
                if not matches:
                    log('All matching processes have been killed.')
                    break
        except KeyboardInterrupt:
            println()
            println()
            warn('Exiting.')
        finally:
            println()

if __name__ == '__main__':
    Kill()