#!/usr/bin/env python3.11

# Copyright (C) 2024-2025 Burak Günaydin
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.

import os
import signal
import time
import psutil

from teatype.cli import BaseCLI
from teatype.logging import log, println

class Kill(BaseCLI):
    """
    A CLI tool to search for processes by name or command‐line fragment,
    display matches, and kill them by index or all at once using
    a sequence of signals (SIGINT, SIGTERM, SIGKILL).
    """
    def meta(self):
        return {
            'name': 'kill',
            'shorthand': 'k',
            'help': 'Search for and kill matching processes interactively'
        }

    def execute(self):
        matches = []

        def refresh_matches(pattern=None):
            nonlocal matches
            matches = []
            if not pattern:
                return
            for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
                try:
                    name = proc.info['name'] or ''
                    cmd  = ' '.join(proc.info['cmdline'] or [])
                    if pattern.lower() in name.lower() or pattern.lower() in cmd.lower():
                        matches.append(proc)
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue

        def display_matches():
            println()
            if not matches:
                log("No matching processes found.")
                return
            log("Matched processes:")
            for idx, proc in enumerate(matches, start=1):
                try:
                    name = proc.name()
                    cmd  = ' '.join(proc.cmdline())
                    log(f"{idx}. pid={proc.pid} name={name} cmd=\"{cmd}\"")
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue

        def kill_procs(procs_to_kill):
            for sig in (signal.SIGINT, signal.SIGTERM, signal.SIGKILL):
                for p in procs_to_kill:
                    try:
                        os.kill(p.pid, sig)
                    except ProcessLookupError:
                        pass
                time.sleep(1)

        try:
            while True:
                display_matches()
                println()
                prompt = ("Enter a search term to refresh matches,\n"
                          "'<number>' to kill one, blank to kill all, "
                          "'q' to quit: ")
                choice = input(prompt).strip()

                if choice.lower() in ('q', 'quit'):
                    break

                if choice == "":
                    if not matches:
                        println("No processes to kill.")
                        continue
                    kill_procs(matches)
                    # filter out dead processes
                    matches = [p for p in matches if p.is_running()]
                    if not matches:
                        println("All matching processes have been killed.")
                        break
                    continue

                if choice.isdigit():
                    idx = int(choice)
                    if 1 <= idx <= len(matches):
                        target = [matches[idx - 1]]
                        kill_procs(target)
                        matches = [p for p in matches if p.is_running()]
                        continue
                    else:
                        println(f"Index {idx} out of range.")
                        continue

                # otherwise treat choice as new search term
                refresh_matches(choice)

        except KeyboardInterrupt:
            println("\nExiting.")
            return

if __name__ == '__main__':
    Kill()