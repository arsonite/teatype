#!/usr/bin/env python3.11

# Copyright (C) 2024-2025 Burak GÃ¼naydin
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.

# System imports
import glob
import json
import os
import re

# From system imports
from typing import List

# From package imports
from teatype.cli import BaseCLI
from teatype.enum import EscapeColor
from teatype.io import env, file, path, shell
from teatype.logging import *

class Aliases(BaseCLI):
    """
    Aliases CLI tool for managing, injecting, ejecting, and listing custom shorthand commands.
    """
    def meta(self):
        """
        Provides metadata for the Aliases CLI commands.

        Returns:
            dict: A dictionary containing metadata details such as name, shorthand, help description, and available commands.
        """
        return {
            'name': 'aliases',
            'shorthand': 'al',
            'help': 'Manage and list aliases for all custom shorthand commands',
            'commands': [
                {
                    'name': 'eject',
                    'shorthand': 'ej',
                    'help': 'Eject all aliases'
                },
                {
                    'name': 'inject',
                    'shorthand': 'in',
                    'help': 'Inject all aliases'
                },
                {
                    'name': 'list',
                    'shorthand': 'ls',
                    'help': 'List all aliases'
                }
            ]
        }
        
    class _Alias:
        """
        Represents a single alias with its properties.
        """
        def __init__(self,
                     name:str,
                     description:str,
                     filename:str,
                     command:str=None,
                     function:List[str]=None):
            """
            Initialize an Alias instance.

            Args:
                name (str): The name of the alias.
                description (str): A brief description of the alias.
                command (str, optional): The command that the alias executes. Defaults to None.
                function (List[str], optional): A list of functions associated with the alias. Defaults to None.

            Raises:
                SystemExit: If neither command nor function is provided.
            """
            # Ensure at least one of command or function is provided
            if not command and not function:
                err('Must provide either "command" or "function" for the alias.', exit=True, traceback=True)
            self.name = name
            self.description = description
            self.filename = filename
            self.command = command
            self.function = function

    def display_aliases(self, aliases_list:List[_Alias]):
        """
        Display the list of current aliases with their descriptions.

        Args:
            aliases_list (List[_Alias]): A list of Alias instances to display.
        """
        println()
        log(f'Found {len(aliases_list)} aliases:')
        grouped_aliases = {}
        for alias in aliases_list:
            if alias.filename not in grouped_aliases:
                grouped_aliases[alias.filename] = []
            grouped_aliases[alias.filename].append(alias)
        
        for filename, aliases in grouped_aliases.items():
            println()
            log(f'{EscapeColor.MAGENTA}{filename.replace(".jsonc", "")}:')
            for alias in aliases:
                log(f'{EscapeColor.LIGHT_CYAN}  {alias.name}: {alias.description}') # Log each alias name and description

    def inject_all_aliases(self, aliases_list:List[_Alias], refresh:bool=True):
        """
        Inject all aliases into the user's shell configuration.

        Args:
            aliases_list (List[_Alias]): A list of Alias instances to inject.
            refresh (bool, optional): Whether to refresh the shell after injection. Defaults to True.
        """
        log('Starting alias injection...', pad_before=1, pad_after=1)
        formatted_aliases = [] # List to hold formatted aliases

        for alias in aliases_list:
            if alias.command:
                # Substitute environment variables in the command
                alias_cmd = env.substitute(alias.command, env.get())
                formatted = f'alias {alias.name}="{alias_cmd}"' # Format the alias command
            elif alias.function:
                # Replace single quotes with double quotes in functions and join them
                function = [function.replace("'", '"') for function in alias.function]
                function = [f'  {line}' for line in function] # Indent each line of the function
                function.insert(0, alias.name + '() {')
                function.append('}')
                formatted = '\n'.join(function) # Combine function lines
            formatted_aliases.append(formatted) # Add to the list

        bashrc_path = os.path.expanduser('~/.bashrc') # Path to the user's .bashrc
        try:
            content = file.read(bashrc_path, force_format='lines') # Read existing .bashrc content
        except FileNotFoundError:
            content = [] # Initialize empty if .bashrc doesn't exist

        start_mark = '# --- TEATYPE ALIASES BEGIN ---\n' # Marker for start of aliases
        end_mark = '# --- TEATYPE ALIASES END ---\n' # Marker for end of aliases
        
        # Check if the aliases block already exists
        start_index = None
        end_index = None
        for i, line in enumerate(content):
            if start_mark in line:
                start_index = i
            if end_mark in line:
                end_index = i
                
        # Remove existing aliases block if present
        if start_index is not None and end_index is not None:
            log('Aliases already exist. Ejecting existing aliases first...')
            self.remove_all_aliases(aliases_list, quiet=True, refresh=False)

        # Re-read the .bashrc after potential removal
        try:
            content = file.read(bashrc_path, force_format='lines')
        except FileNotFoundError:
            content = []

        new_content = content # Initialize new content with existing .bashrc
        new_content.append('\n') # Add a new line for separation
        # Append the new aliases between the start and end markers
        new_content.append(start_mark)
        for alias in formatted_aliases:
            new_content.append(f'{alias}\n') # Add each formatted alias
        new_content.append(end_mark)

        try:
            file.write(bashrc_path, new_content, force_format='lines') # Write updated content to .bashrc
        except Exception as e:
            err(f"Failed to write to {bashrc_path}: {e}", exit=True, traceback=True)

        log(f'Added aliases: {len(formatted_aliases)}', pad_after=1)
        log('Alias injection complete.')

        if refresh:
            log('Refreshing shell to apply changes...')
            shell(f'. {bashrc_path}') # Source the updated .bashrc
            # FIXME: Probably this code here causing hanging processes
            shell('exec bash') # Restart the shell
        else:
            hint('To apply changes, run `$ exec bash`.', pad_before=1)

    def remove_all_aliases(self, aliases_list:List[_Alias], quiet:bool=False, refresh:bool=True):
        """
        Remove all injected aliases from the user's shell configuration.

        Args:
            aliases_list (List[_Alias]): A list of Alias instances to remove.
            quiet (bool, optional): If True, suppresses logs. Defaults to False.
            refresh (bool, optional): Whether to refresh the shell after removal. Defaults to True.
        """
        bashrc_path = os.path.expanduser('~/.bashrc') # Path to the user's .bashrc
        start_mark = '# --- TEATYPE ALIASES BEGIN ---\n' # Marker for start of aliases
        end_mark = '# --- TEATYPE ALIASES END ---\n' # Marker for end of aliases

        try:
            lines = file.read(bashrc_path, force_format='lines') # Read existing .bashrc content
        except FileNotFoundError:
            lines = [] # Initialize empty if .bashrc doesn't exist
            
        filtered_lines = [] # List to hold lines after removal
        skip = False # Flag to indicate skipping lines between markers
        
        # Validate that both start and end markers are present
        if start_mark in lines and end_mark not in lines:
            err('Found start mark but not end mark. Aborting.', exit=True, traceback=True)
        if start_mark not in lines and end_mark in lines:
            err('Found end mark but not start mark. Aborting.', exit=True, traceback=True)
        if start_mark not in lines and end_mark not in lines:
            if not quiet:
                println()
                log('No aliases found to remove.')
            return # Nothing to remove
        
        if not quiet:
            log('Removing all injected aliases...', pad_before=1)

        # Iterate through each line to filter out the aliases block
        for line in lines:
            if line.strip() == start_mark.strip():
                skip = True # Start skipping lines
                continue
            if line.strip() == end_mark.strip():
                skip = False # Stop skipping lines
                continue
            if not skip:
                filtered_lines.append(line) # Keep lines outside the markers
                
        # Remove trailing empty lines for cleanliness
        while filtered_lines and not filtered_lines[-1].strip():
            filtered_lines.pop()
                
        try:
            file.write(bashrc_path, filtered_lines, force_format='lines') # Write updated content to .bashrc
        except Exception as e:
            err(f"Failed to write to {bashrc_path}: {e}", exit=True, traceback=True)

        if not quiet:
            log(f'Removed lines: {len(filtered_lines)}', pad_after=1)

        log('All aliases removed.')

        if refresh:
            if not quiet:
                log('Refreshing shell to apply changes...')
            shell(f'. {bashrc_path}') # Source the updated .bashrc
            # FIXME: Probably this code here causing hanging processes
            shell('exec bash') # Restart the shell
        else:
            if not quiet:
                hint('To apply changes, run `$ exec bash`.', pad_before=1)

    # FIXME: Not working completely, but fix later, no time now
    def create_bashrc_backup(self):
        """
        Create a backup of the user's .bashrc file.

        This method performs the following steps:
        1. Determines the path to the user's .bashrc file.
        2. Reads the CLI configuration to obtain backup settings.
        3. Ensures the distribution directory exists for storing backups.
        4. Optionally creates an original backup of .bashrc if configured.
        5. Manages backup files by maintaining a maximum number of backups.
           It removes the oldest backup if the maximum is exceeded and shifts existing backups.
        6. Creates a new backup of the current .bashrc file.
        """
        bashrc_path = os.path.expanduser('~/.bashrc') # Expand the user's home directory and get the .bashrc path

        # Read the CLI configuration file to obtain backup settings
        aliases_config = file.read(path.join(path.caller_parent(reverse_depth=2), 'config', 'aliases.ini'))
        bashrc_max_backups = int(aliases_config.get('BACKUP', 'bashrc_max_backups')) # Maximum number of backups to keep
        keep_original_bashrc_backup = aliases_config.get('BACKUP', 'keep_original_bashrc_backup') # Flag to keep the original .bashrc backup

        dist_directory = path.join(path.caller_parent(reverse_depth=2), 'dist') # Path to the distribution directory for backups
        os.makedirs(dist_directory, exist_ok=True) # Create the dist directory if it doesn't exist

        if keep_original_bashrc_backup:
            original_backup_path = path.join(dist_directory, '.bashrc.original.bak') # Path for the original .bashrc backup
            if not file.exists(original_backup_path):
                try:
                    file.copy(bashrc_path, original_backup_path) # Create a backup of the original .bashrc
                    log(f'Created backup of original .bashrc at {original_backup_path}.') # Log successful backup creation
                except Exception as e:
                    err(f"Failed to create backup of original .bashrc: {e}", exit=True, pad_after=1, traceback=True) # Handle copy failure

        # Define the pattern to identify existing backup files
        backup_pattern = path.join(dist_directory, 'bashrc.bak.*') # Pattern to match backup files like bashrc.bak.1, bashrc.bak.2, etc.
        backup_files = glob.glob(backup_pattern) # Retrieve all backup files matching the pattern

        # Extract backup numbers from filenames and sort them in ascending order
        backup_numbers = []
        for bf in backup_files:
            match = re.match(r'bashrc\.bak\.(\d+)$', os.path.basename(bf)) # Use regex to extract the numerical part
            if match:
                backup_numbers.append(int(match.group(1))) # Add the backup number to the list
        backup_numbers.sort() # Sort backup numbers to identify the oldest backup

        # Remove the oldest backup if the number of backups exceeds the maximum allowed
        if len(backup_numbers) >= bashrc_max_backups:
            oldest_backup = path.join(dist_directory, f'bashrc.bak.{backup_numbers[0]}') # Path to the oldest backup
            file.remove(oldest_backup) # Delete the oldest backup file
            backup_numbers.pop(0) # Remove the oldest backup number from the list

            # Shift remaining backups to maintain the backup numbering sequence
            for num in backup_numbers:
                src = path.join(dist_directory, f'bashrc.bak.{num}') # Current backup file path
                dst = path.join(dist_directory, f'bashrc.bak.{num - 1}') # New backup file path after shifting
                file.move(src, dst) # Rename/move the backup file to the new path

        # Define the path for the new backup based on the maximum backups allowed
        backup_path = path.join(dist_directory, f'bashrc.bak.{bashrc_max_backups}') # New backup file path
        try:
            file.copy(bashrc_path, backup_path) # Create a new backup of the current .bashrc
        except Exception as e:
            # Handle copy failure
            err(f"Failed to create backup of .bashrc: {e}", exit=True, pad_after=1, traceback=True) 

    def execute(self):
        """
        Execute the appropriate alias command based on user input.
        """
        command = self.get_command() # Retrieve the user command
        
        TEATYPE_CLI_PATH = env.get('TEATYPE_CLI_PATH', None)
        if TEATYPE_CLI_PATH is None:
            err('Environment variable TEATYPE_CLI_PATH is not set. Please inject env variables with `tt env inject` first.',
                exit=True)

        aliases_path_default = path.join(TEATYPE_CLI_PATH, 'files', 'aliases') # Default aliases path

        try:
            self.create_bashrc_backup() # Create a backup of the user's .bashrc file

            aliases_objects = []
            for f in file.list(aliases_path_default):
                filename = f.name
                if 'disabled' in filename:
                    continue
                
                aliases = file.read(f.path)
                
                # Create Alias objects from the JSON data
                aliases_objects.extend([self._Alias(**alias, filename=filename) for alias in aliases])

            if command == 'list':
                self.display_aliases(aliases_objects)
            elif command == 'eject':
                # FIXME: Disabling refresh for now until I can fix hanging processes
                self.remove_all_aliases(aliases_objects, refresh=False)
            elif command == 'inject':
                self.inject_all_aliases(aliases_objects, refresh=False)
            println()
        except json.JSONDecodeError:
            err(f'Error parsing aliases file at "{aliases_path_default}". Please verify its correct format or run "aliases reset".', exit=True)
        except Exception:
            err('An unexpected error occurred while handling aliases.', exit=True, traceback=True)
        
if __name__ == '__main__':
    Aliases()